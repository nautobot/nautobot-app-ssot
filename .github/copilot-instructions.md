# Copilot Repository Instructions — Nautobot App (cookiecutter)

You are **GitHub Copilot** working inside a **Nautobot App (plugin)** repository generated by the `cookiecutter-nautobot-app` template (v2.5.x). Your mission is to generate **small, readable, test‑backed** changes that follow **Nautobot patterns** and this repository’s tooling and style.

> **Location:** Save this file at `.github/copilot-instructions.md`.  
> **Scope:** You may also add path‑scoped rules via `.github/instructions/*.instructions.md` if truly necessary.

---

## 0) Quick Facts (for Copilot)

- **Stack:** Django app that runs inside **Nautobot** (network SoT & automation). Uses Postgres, Redis, and Celery via Nautobot. Prefer idiomatic **Django** and **Nautobot helper APIs**.
- **Python:** 3.9–3.12 commonly in use.
- **Dependency & venv:** **Poetry** only.
- **Task runner:** `invoke` (always via Poetry).
- **Style:** Ruff + Pylint; **imports at the top**; prefer **docstrings over inline comments**; clear, explicit code.

---

## 1) Tooling & Environment (Poetry‑first)

Always use Poetry for dependency management and virtualenvs.

- Install deps:  
  `poetry install`
- **Run tasks (required):**  
  `poetry run invoke <task> [args]`

Examples:
- `poetry run invoke ruff --autoformat`
- `poetry run invoke ruff`
- `poetry run invoke pylint`
- `poetry run invoke tests`
- `poetry run invoke check-migrations`
- `poetry run invoke makemigrations -n <name>`

Prefer `invoke` tasks over ad‑hoc commands. **When suggesting commands, prefix them with `poetry run`.**

---

## 2) Style, Lint, and Documentation

- **Ruff** is used for formatting and linting; **Pylint** for static analysis. Generated code must pass both.
- **Imports:**  
  - Place **all imports at the top** of the file (after the module docstring).  
  - No wildcard imports; prefer absolute imports and explicit symbols.  
  - Aliasing Nautobot app modules is fine for clarity, e.g.:  
    `from nautobot.ipam import models as ipam_models`
- **Docstrings > inline comments:**  
  - Keep inline comments to the minimum for non‑obvious logic.  
  - Put purpose/params/returns/side‑effects in **module/class/function docstrings**.  
- Write straightforward, readable code over clever one‑liners.

---

## 3) Use Nautobot’s Frameworks (default choices)

When scaffolding features, use Nautobot’s base classes and helpers first:

- **Models:** `PrimaryModel` (full Nautobot features) or `BaseModel` as appropriate.
- **Forms:** `NautobotModelForm` (+ `NautobotBulkEditForm` for bulk edits).
- **FilterSets:** `NautobotModelFilterSet` (`Meta.fields = "__all__"` unless strongly justified).
- **Serializers:** `NautobotModelSerializer` (writeable) / `BaseModelSerializer` (simple read‑only).
- **API views:** `NautobotModelViewSet`.
- **UI views:** `NautobotUIViewSet` (unifies list/detail/edit/delete).
- **URLs/Routes:** Use helpers such as `get_route_for_model()`; do **not** hand‑craft route strings.

**Why:** These reduce boilerplate, align with core Nautobot behavior, and improve maintainability.

---

## 4) Models & Data Layer

- Prefer natural keys (e.g., unique `name`) or PKs; add `slug` only with clear rationale.
- Use constants for text lengths (e.g., `CHARFIELD_MAX_LENGTH`).
- Avoid `null=True` on strings; use empty string `""` when semantically empty.
- For `ManyToManyField`, declare an explicit **through** model.
- If searchable, populate `search_fields`.
- Add DB indexes when fields are frequently filtered; justify in the migration message.

---

## 5) Forms, Filters, Templates, and UI Patterns

- **Forms:**  
  - Use `DynamicModelChoiceField` for large foreign keys.  
  - Put complex validation in `clean()` (model or form as appropriate).
- **Filters:**  
  - Use `RelatedMembershipBooleanFilter` for boolean relationship filters (`has_*`).  
  - Use `NaturalKeyOrPKMultipleChoiceFilter` for FK filters where applicable.
- **Templates:**  
  - Extend Nautobot base templates; prefer provided filters (`|hyperlinked_object`, `|placeholder`, etc.) over `mark_safe`/hand‑rolled anchors.
- **UI Patterns:**  
  - Prefer **tabs** (via `NautobotUIViewSet`) for distinct data categories.  
  - Use full‑width detail layouts for dense content.  
  - Provide **stats tiles** / instance counts if helpful.  
  - For long‑running actions, use **AJAX modal + polling** (Jobs/Celery).  
  - Use inline edit sparingly and always re‑validate server‑side.

---

## 6) Migrations

- If models change:  
  - `poetry run invoke check-migrations`  
  - `poetry run invoke makemigrations -n <meaningful_name>`
- Keep schema and data migrations separate and reversible.
- Use descriptive migration names (e.g., `devicenote_initial`, `provider_increase_account_length`).
- Ruff‑format generated migrations for consistency.

---

## 7) Tests — What to Generate (Nautobot‑style, **required**)

**Use Nautobot’s testing base classes and mixins. Don’t use `unittest.TestCase` or raw `django.test.TestCase`.**

### 7.1 Test Types & Base Classes

- **Unit tests:** inherit from `nautobot.core.testing.TestCase` (auto‑tagged `unit`).
- **View tests:** use `nautobot.core.testing.views.ViewTestCases` mixins.
- **API tests:** use `nautobot.core.testing.api.APIViewTestCases` mixins  
  (`CreateObjectViewTestCase`, `ListObjectsViewTestCase`, `GetObjectViewTestCase`,  
  `UpdateObjectViewTestCase`, `DeleteObjectViewTestCase`, and bulk variants).  
  These enforce `?brief=` behavior (declare `brief_fields`) and exercise bulk endpoints.
- **Filter tests:** use `nautobot.core.testing.filters.FilterTestCases` (generic boolean/multi‑choice/tags tests).
- **Form tests:** use `nautobot.core.testing.forms.FormTestCases.BaseFormTestCase`.
- **Integration (browser) tests:** `nautobot.core.testing.integration.SeleniumTestCase` (auto‑tagged `integration`).
- **Migration tests:** `django_test_migrations.MigratorTestCase` (auto‑tagged `migration_test`).

### 7.2 Directory Layout

```
<app>/tests/
  test_models.py
  test_filters.py
  test_api.py
  test_views.py
  integration/
    test_*.py
  migration/
    test_*.py
```

### 7.3 Running Tests

- All tests (fast fixtures enabled):  
  `poetry run invoke tests`
- Filter by expression:  
  `poetry run invoke tests -- -k "<pattern>"`
- Last failed:  
  `poetry run invoke tests -- --lf`
- Only **integration** tests:  
  `poetry run invoke tests -- --tag integration`
- Only **migration** tests:  
  `poetry run invoke tests -- --tag migration_test`

### 7.4 Test Data & Fixtures

- Prefer creating objects via model `.create()`/`.save()` inside tests.  
- Avoid calling factories in `setUp()` / `setUpTestData()`; factory output can be stateful.  
- Rely on cached/seeded fixtures where provided by the runner to keep tests fast and deterministic.

### 7.5 API Test Skeleton (what Copilot should scaffold)

```python
"""API tests for Widget."""
from nautobot.core.testing.api import APIViewTestCases
from . import models

class WidgetAPITests(
    APIViewTestCases.CreateObjectViewTestCase,
    APIViewTestCases.ListObjectsViewTestCase,
    APIViewTestCases.GetObjectViewTestCase,
    APIViewTestCases.UpdateObjectViewTestCase,
    APIViewTestCases.DeleteObjectViewTestCase,
):
    """CRUD tests for the Widget REST API."""
    model = models.Widget

    # Returned keys for `?brief=true` (sorted)
    brief_fields = ["display", "id", "name", "url"]

    @classmethod
    def _get_queryset(cls):
        return models.Widget.objects.all()

    create_data = [
        {"name": "Widget A"},
        {"name": "Widget B"},
    ]
    update_data = {"name": "Widget A+"}
```

### 7.6 Filter Test Skeleton

```python
"""Filter tests for Widget."""
from nautobot.core.testing.filters import FilterTestCases
from . import filters as widget_filters, models

class WidgetFilterTests(FilterTestCases.FilterTestCase):
    """Generic filter assertions for WidgetFilterSet."""
    filterset = widget_filters.WidgetFilterSet
    queryset = models.Widget.objects.all()

    # Optional: map filter names to queryset kwargs to exercise generic cases.
    generic_filter_tests = [
        ["name", "name"],
        # ["owner_id", "owner__id"],
    ]
```

### 7.7 Views Test Skeleton

```python
"""View tests for Widget UI."""
from nautobot.core.testing.views import ViewTestCases
from . import models

class WidgetUIViewTests(ViewTestCases.PrimaryObjectViewTestCase):
    """UI list/detail/create/edit/delete tests for Widget."""
    model = models.Widget
    bulk_edit_data = {"name": "Bulk Renamed"}
```

### 7.8 OpenAPI Schema Checks

Add a lightweight OpenAPI schema test using Nautobot’s provided test cases to ensure your app’s endpoints and serializers remain schema‑valid.

---

## 8) Celery & Jobs

- For long‑running work or external calls, prefer **Celery tasks** or **Nautobot Jobs**.  
- Do **not** block web requests with heavy processing.

---

## 9) Security & Secrets

- Never hard‑code secrets/tokens/credentials.  
- Use Nautobot Secrets / External Integrations.  
- Scrub PII and sensitive network details from examples/tests.

---

## 10) Performance & DB

- Prefer queryset filters/bulk ops over per‑row loops.  
- Use `select_related` / `prefetch_related` where appropriate.  
- Add indexes for frequently filtered fields; justify in migration message.

---

## 11) Git & Branching

- Small, focused branches.  
- PRs must include tests, migration notes (if any), and “how to test” steps.  
- Reference related issues.  
- Target the repository’s active development branch (not `main` if `main` is reserved for releases).

---

## 12) Pre‑commit

Assume contributors have `pre-commit` enabled. Your output should pass hooks (Ruff, Markdown lint, etc.). To run manually:

```
poetry run pre-commit run -a
```

---

## 13) PR Hygiene — What Copilot Should Suggest

- Clear, action‑oriented title and description.  
- Link to issue(s) and include screenshots/GIFs for UI work.  
- Call out any migrations and potential data impacts.  
- Keep the diff small and logically cohesive.

---

## 14) Snippets Copilot Should Prefer

**Model**
```python
"""DeviceNote model."""
from django.db import models
from nautobot.core.models.generics import PrimaryModel

class DeviceNote(PrimaryModel):
    """Freeform note attached to a device."""
    name = models.CharField(max_length=255, unique=True)
    content = models.TextField(blank=True, default="")

    class Meta:
        ordering = ("name",)
```

**Serializer**
```python
"""Serializer for DeviceNote."""
from nautobot.core.api.serializers import NautobotModelSerializer
from .models import DeviceNote

class DeviceNoteSerializer(NautobotModelSerializer):
    """Serialize DeviceNote objects."""
    class Meta:
        model = DeviceNote
        fields = "__all__"
```

**FilterSet**
```python
"""FilterSet for DeviceNote."""
from nautobot.core.filters import BaseFilterSet
from .models import DeviceNote

class DeviceNoteFilter(BaseFilterSet):
    """Filter DeviceNote by name/content."""
    class Meta:
        model = DeviceNote
        fields = "__all__"
```

**API ViewSet**
```python
"""API viewset for DeviceNote."""
from nautobot.core.api.views import NautobotModelViewSet
from .filters import DeviceNoteFilter
from .serializers import DeviceNoteSerializer
from .models import DeviceNote

class DeviceNoteViewSet(NautobotModelViewSet):
    """List, retrieve, and manage DeviceNotes via REST API."""
    queryset = DeviceNote.objects.all()
    serializer_class = DeviceNoteSerializer
    filterset_class = DeviceNoteFilter
```

**UI ViewSet**
```python
"""UI viewset for DeviceNote."""
from nautobot.core.views import NautobotUIViewSet
from .models import DeviceNote
from .tables import DeviceNoteTable
from .forms import DeviceNoteForm

class DeviceNoteUIViewSet(NautobotUIViewSet):
    """UI for listing, viewing, creating, and editing DeviceNotes."""
    queryset = DeviceNote.objects.all()
    table = DeviceNoteTable
    bulk_update_form_class = DeviceNoteForm
    form_class = DeviceNoteForm
```

**Tests (API smoke)**
```python
"""API smoke test for DeviceNote list."""
import unittest
from django.urls import reverse

@unittest.mark.django_db
def test_device_note_list(api_client):
    url = reverse("plugins-api:<your_app_label>-api:devicenote-list")
    resp = api_client.get(url)
    assert resp.status_code == 200
```

**Migrations (command)**
```
poetry run invoke makemigrations -n devicenote_initial
```

---

## 15) Optional: Folder‑Specific Instructions

If needed, add `.github/instructions/*.instructions.md` with path‑scoped front‑matter to apply specialized guidance to certain subtrees (e.g., `docs/`, `nautobot_plugin_tooling/`). Keep rules minimal to avoid confusion.

---

## 16) Final Checklist (for every change)

- [ ] Commands are shown as `poetry run invoke ...`  
- [ ] Imports are at the top; docstrings explain intent/usage  
- [ ] Nautobot base classes, viewsets, and helpers are used  
- [ ] Tests cover models/filters/API/views with Nautobot base classes & mixins  
- [ ] Migrations are checked/generated, named meaningfully, and reversible  
- [ ] Querysets are optimized; indexes added if needed  
- [ ] No secrets/PII in code, tests, or docs  
- [ ] Pre‑commit hooks pass; Ruff & Pylint clean  
- [ ] PR description includes “how to test” and references related issues


### 7.9 Unittest Task (Django/Nautobot runner)

In addition to `invoke tests` (the default Nautobot test runner), this repo can use **Django’s unittest-style runner**
via the `unittest` Invoke task when present. Prefer this when you want stock unittest
selection semantics or when a plugin/app intends to mirror Nautobot core’s runner behavior.

**Help**  
```
poetry run invoke unittest -h
```
```
Usage: inv[oke] [--core-opts] unittest [--options] [other tasks here ...]

Docstring:
  Run Nautobot unit tests.

Options:
  -b, --[no-]buffer             Discard output from passing tests
  -c, --coverage                Enable coverage reporting. Defaults to False
  -f, --failfast                Fail fast on first failure
  -k, --keepdb                  Re-use the test database between runs
  -l STRING, --label=STRING     Directory or module label to test (runs subset)
  -p STRING, --pattern=STRING   Select specific test methods/classes/modules
  -s, --skip-docs-build         Skip building docs before tests
  -v, --verbose                 Verbose test output
```

**When to use which**  
- Use `poetry run invoke tests` for the full unittest experience (fixtures, markers, rich plugins).  
- Use `poetry run invoke **unittest**` for Django/unittest-native selection (labels/patterns), quick targeted runs, or parity with Nautobot core’s CI jobs.

**Common recipes**  
- Run with coverage:  
  `poetry run invoke unittest --coverage`
- Target a specific module (label):  
  `poetry run invoke unittest --label myapp.tests.test_api`
- Match by pattern (method/class):  
  `poetry run invoke unittest --pattern "WidgetAPITests and test_list_objects"`
- Re-use the DB between runs for speed:  
  `poetry run invoke unittest --keepdb`
- Fail fast & suppress noise from passing tests:  
  `poetry run invoke unittest --failfast --buffer`
- Skip docs build if unchanged:  
  `poetry run invoke unittest --skip-docs-build`

> **Note:** Always prefix with `poetry run` to ensure tests execute inside the project’s Poetry environment.


---

## 17) Authoritative Nautobot Repositories & Examples

When proposing or generating **Nautobot-specific code**, prefer patterns proven in the official repositories below.  
Use them for import paths, base-class usage, testing mixins, viewset patterns, job/celery conventions, and UI Component Framework examples.

- **Nautobot Core:** https://github.com/nautobot/nautobot/
- **Nautobot App — SSoT:** https://github.com/nautobot/nautobot-app-ssot
- **Nautobot App — Nornir:** https://github.com/nautobot/nautobot-app-nornir
- **Nautobot App — Golden Config:** https://github.com/nautobot/nautobot-app-golden-config
- **Nautobot App — DNS Models:** https://github.com/nautobot/nautobot-app-dns-models
- **Nautobot App — Firewall Models:** https://github.com/nautobot/nautobot-app-firewall-models
- **Nautobot App — BGP Models:** https://github.com/nautobot/nautobot-app-bgp-models

**Guidance for Copilot**  
- Prefer examples from these repos over generic Django code.  
- Mirror **base class** usage (`PrimaryModel`, `NautobotModelViewSet`, `NautobotUIViewSet`, etc.).  
- Follow **testing** patterns under `nautobot/core/testing` (mixins and tags) rather than ad‑hoc tests.  
- Reuse **filter/serializer** patterns and import paths exactly as shown in the official code.  
- Avoid v1-only patterns; target **Nautobot 2.x** APIs and UI Component Framework.  
- If proposing URLs, prefer helper utilities (e.g., `get_route_for_model`) visible in Nautobot core, not hard‑coded strings.
